{"ast":null,"code":"/**\n * Modle requirements\n */\n\nvar isArray = require('isarray');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function (packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  function deconstructBinPackRecursive(data) {\n    if (!data) return data;\n    if (global.Buffer && Buffer.isBuffer(data) || global.ArrayBuffer && data instanceof ArrayBuffer) {\n      // replace binary\n      var placeholder = {\n        _placeholder: true,\n        num: buffers.length\n      };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = deconstructBinPackRecursive(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = deconstructBinPackRecursive(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n  var pack = packet;\n  pack.data = deconstructBinPackRecursive(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {\n    packet: pack,\n    buffers: buffers\n  };\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function (packet, buffers) {\n  var curPlaceHolder = 0;\n  function reconstructBinPackRecursive(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = reconstructBinPackRecursive(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = reconstructBinPackRecursive(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n  packet.data = reconstructBinPackRecursive(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function (data, callback) {\n  function removeBlobsRecursive(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function () {\n        // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        } else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if (! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    }\n\n    if (isArray(obj)) {\n      // handle array\n      for (var i = 0; i < obj.length; i++) {\n        removeBlobsRecursive(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) {\n      // and object\n      for (var key in obj) {\n        removeBlobsRecursive(obj[key], key, obj);\n      }\n    }\n  }\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  removeBlobsRecursive(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\nfunction isBuf(obj) {\n  return global.Buffer && Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;\n}","map":{"version":3,"names":["isArray","require","exports","deconstructPacket","packet","buffers","packetData","data","deconstructBinPackRecursive","global","Buffer","isBuffer","ArrayBuffer","placeholder","_placeholder","num","length","push","newData","Array","i","Date","key","pack","attachments","reconstructPacket","curPlaceHolder","reconstructBinPackRecursive","buf","undefined","removeBlobs","callback","removeBlobsRecursive","obj","curKey","containingObject","Blob","File","pendingBlobs","fileReader","FileReader","onload","result","bloblessData","readAsArrayBuffer","isBuf"],"sources":["/home/y4n/node_modules/socket.io-parser/binary.js"],"sourcesContent":["/**\n * Modle requirements\n */\n\nvar isArray = require('isarray');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet) {\n    var buffers = [];\n    var packetData = packet.data;\n\n    function deconstructBinPackRecursive(data) {\n        if (!data) return data;\n\n        if ((global.Buffer && Buffer.isBuffer(data)) ||\n            (global.ArrayBuffer && data instanceof ArrayBuffer)) { // replace binary\n            var placeholder = {_placeholder: true, num: buffers.length};\n            buffers.push(data);\n            return placeholder;\n        } else if (isArray(data)) {\n            var newData = new Array(data.length);\n            for (var i = 0; i < data.length; i++) {\n                newData[i] = deconstructBinPackRecursive(data[i]);\n            }\n            return newData;\n        } else if ('object' == typeof data && !(data instanceof Date)) {\n            var newData = {};\n            for (var key in data) {\n                newData[key] = deconstructBinPackRecursive(data[key]);\n            }\n            return newData;\n        }\n        return data;\n    }\n\n    var pack = packet;\n    pack.data = deconstructBinPackRecursive(packetData);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return {packet: pack, buffers: buffers};\n}\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\n exports.reconstructPacket = function(packet, buffers) {\n    var curPlaceHolder = 0;\n\n    function reconstructBinPackRecursive(data) {\n        if (data && data._placeholder) {\n            var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n            return buf;\n        } else if (isArray(data)) {\n            for (var i = 0; i < data.length; i++) {\n                data[i] = reconstructBinPackRecursive(data[i]);\n            }\n            return data;\n        } else if (data && 'object' == typeof data) {\n            for (var key in data) {\n                data[key] = reconstructBinPackRecursive(data[key]);\n            }\n            return data;\n        }\n        return data;\n    }\n\n    packet.data = reconstructBinPackRecursive(packet.data);\n    packet.attachments = undefined; // no longer useful\n    return packet;\n }\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n\n  function removeBlobsRecursive(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    }\n\n    if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        removeBlobsRecursive(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        removeBlobsRecursive(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  removeBlobsRecursive(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n}\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\nfunction isBuf(obj) {\n  return (global.Buffer && Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}