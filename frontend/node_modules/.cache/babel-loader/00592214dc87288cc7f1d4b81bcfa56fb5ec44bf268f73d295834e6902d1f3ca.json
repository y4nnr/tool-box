{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar debug = require('debug')('engine.io-client:websocket');\n\n/**\n * `ws` exposes a WebSocket-compatible interface in\n * Node, or the `WebSocket` or `MozWebSocket` globals\n * in the browser.\n */\n\nvar WebSocket = require('ws');\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS(opts) {\n  var forceBase64 = opts && opts.forceBase64;\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n  var self = this;\n  var uri = this.uri();\n  var protocols = void 0;\n  var opts = {\n    agent: this.agent\n  };\n  this.ws = new WebSocket(uri, protocols, opts);\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n  this.ws.binaryType = 'arraybuffer';\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Override `onData` to use a timer on iOS.\n * See: https://gist.github.com/mloughran/2052006\n *\n * @api private\n */\n\nif ('undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\n  WS.prototype.onData = function (data) {\n    var self = this;\n    setTimeout(function () {\n      Transport.prototype.onData.call(self, data);\n    }, 0);\n  };\n}\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  for (var i = 0, l = packets.length; i < l; i++) {\n    parser.encodePacket(packets[i], this.supportsBinary, function (data) {\n      //Sometimes the websocket has already been closed but the browser didn't\n      //have a chance of informing us about it yet, in that case send will\n      //throw an error\n      try {\n        self.ws.send(data);\n      } catch (e) {\n        debug('websocket closed before onclose event');\n      }\n    });\n  }\n  function ondrain() {\n    self.writable = true;\n    self.emit('drain');\n  }\n  // fake drain\n  // defer to next tick to allow Socket to clear writeBuffer\n  setTimeout(ondrain, 0);\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && ('wss' == schema && this.port != 443 || 'ws' == schema && this.port != 80)) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = +new Date();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function () {\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};","map":{"version":3,"names":["Transport","require","parser","parseqs","inherit","debug","WebSocket","module","exports","WS","opts","forceBase64","supportsBinary","call","prototype","name","doOpen","check","self","uri","protocols","agent","ws","binaryType","undefined","addEventListeners","onopen","onOpen","onclose","onClose","onmessage","ev","onData","data","onerror","e","onError","navigator","test","userAgent","setTimeout","write","packets","writable","i","l","length","encodePacket","send","ondrain","emit","doClose","close","query","schema","secure","port","timestampRequests","timestampParam","Date","b64","encode","hostname","path"],"sources":["/home/y4n/node_modules/engine.io-client/lib/transports/websocket.js"],"sourcesContent":["/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar debug = require('debug')('engine.io-client:websocket');\n\n/**\n * `ws` exposes a WebSocket-compatible interface in\n * Node, or the `WebSocket` or `MozWebSocket` globals\n * in the browser.\n */\n\nvar WebSocket = require('ws');\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var self = this;\n  var uri = this.uri();\n  var protocols = void(0);\n  var opts = { agent: this.agent };\n\n  this.ws = new WebSocket(uri, protocols, opts);\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  this.ws.binaryType = 'arraybuffer';\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function(){\n  var self = this;\n\n  this.ws.onopen = function(){\n    self.onOpen();\n  };\n  this.ws.onclose = function(){\n    self.onClose();\n  };\n  this.ws.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Override `onData` to use a timer on iOS.\n * See: https://gist.github.com/mloughran/2052006\n *\n * @api private\n */\n\nif ('undefined' != typeof navigator\n  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\n  WS.prototype.onData = function(data){\n    var self = this;\n    setTimeout(function(){\n      Transport.prototype.onData.call(self, data);\n    }, 0);\n  };\n}\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  for (var i = 0, l = packets.length; i < l; i++) {\n    parser.encodePacket(packets[i], this.supportsBinary, function(data) {\n      //Sometimes the websocket has already been closed but the browser didn't\n      //have a chance of informing us about it yet, in that case send will\n      //throw an error\n      try {\n        self.ws.send(data);\n      } catch (e){\n        debug('websocket closed before onclose event');\n      }\n    });\n  }\n\n  function ondrain() {\n    self.writable = true;\n    self.emit('drain');\n  }\n  // fake drain\n  // defer to next tick to allow Socket to clear writeBuffer\n  setTimeout(ondrain, 0);\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function(){\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function(){\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = +new Date;\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function(){\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}